local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Window = OrionLib:MakeWindow({Name = "Galatic - Made By Intrns", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})

local Combat = Window:MakeTab({
	Name = "Aimlock",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false})


local Section = Combat:AddSection({
	Name = "Aimlock Options"
})


local Esp = Window:MakeTab({
	Name = "Esp",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})


local Section = Esp:AddSection({
	Name = "Esp Options"
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local CurrentCamera = Workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Drawing = Drawing or {}


local aimbotEnabled = true
local aimKey = Enum.KeyCode.LeftShift
local aimSmoothness = 3.9
local aimlockDistance = 489
local aimSpeedX = 1.5  
local aimSpeedY = 1.5 
local fovEnabled = false
local fovRadius = 100
local fovVisible = false
local rainbowFov = false
local dynamicFOV = false
local predictionEnabled = false
local predictionAmount = 5
local hitChance = 75
local aimPart = "UpperTorso"
local aimMode = "On-Hold"
local fovShape = "Circle"
local switchTarget = false
local filterByTeam = false
local filterByHealth = false
local randomizeHitChance = false
local prioritizeLowHealth = false
local autoDisableAim = true
local autoDisableDistance = 489

local x = 0
local y = 0
local z = 0

local autoFire = false
local aimOffset = Vector3.new(x, y, z)
local velocityPrediction = true
local smartSwitch = false

local function getRainbowColor(t)
    local r = math.sin(t * 2 * math.pi) * 0.5 + 0.5
    local g = math.sin(t * 2 * math.pi + 2 * math.pi / 3) * 0.5 + 0.5
    local b = math.sin(t * 2 * math.pi + 4 * math.pi / 3) * 0.5 + 0.5
    return Color3.new(r, g, b)
end

local fovShapeDrawing
local function drawFOVShape()
    if not fovEnabled or not fovVisible then
        if fovShapeDrawing then
            fovShapeDrawing.Visible = false
        end
        return
    end

    local mouseLocation = UserInputService:GetMouseLocation()
    local fovColor = rainbowFov and getRainbowColor(tick() % 5 / 5) or Color3.new(1, 1, 1)
    
    if not fovShapeDrawing then
        if fovShape == "Circle" then
            fovShapeDrawing = Drawing.new("Circle")
            fovShapeDrawing.Radius = fovRadius
        elseif fovShape == "Square" then
            fovShapeDrawing = Drawing.new("Square")
            fovShapeDrawing.Size = Vector2.new(fovRadius * 2, fovRadius * 2)
        end
        fovShapeDrawing.Thickness = 1
        fovShapeDrawing.Filled = false
    end

    if fovShape == "Circle" then
        fovShapeDrawing.Position = Vector2.new(mouseLocation.X, mouseLocation.Y)
        fovShapeDrawing.Radius = fovRadius
    elseif fovShape == "Square" then
        fovShapeDrawing.Position = Vector2.new(mouseLocation.X - fovRadius, mouseLocation.Y - fovRadius)
        fovShapeDrawing.Size = Vector2.new(fovRadius * 2, fovRadius * 2)
    end
    
    fovShapeDrawing.Color = fovColor
    fovShapeDrawing.Visible = true
end

local function getAimPart(target)
    local aimPart = target.Character:FindFirstChild(aimPart)
    if aimPart then
        return aimPart.Position + aimOffset 
    else
        return target.Character:FindFirstChild("UpperTorso").Position + aimOffset
    end
end

local function shouldHit()
    if randomizeHitChance then
        return math.random(1, 100) <= math.random(hitChance - 10, hitChance + 10)
    else
        return math.random(1, 100) <= hitChance
    end
end

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local lowestHealth = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and getAimPart(player) and player.Character:FindFirstChild("Humanoid") then
            local isOnTeam = (not filterByTeam) or (player.Team ~= LocalPlayer.Team)
            local hasHealth = (not filterByHealth) or (player.Character.Humanoid.Health > 0)
            if isOnTeam and hasHealth then
                local distanceToPlayer = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if distanceToPlayer <= aimlockDistance then
                    local screenPoint = CurrentCamera:WorldToScreenPoint(getAimPart(player))
                    local mouseLocation = UserInputService:GetMouseLocation()
                    local distance = (Vector2.new(mouseLocation.X, mouseLocation.Y) - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude

                    if prioritizeLowHealth and player.Character.Humanoid.Health < lowestHealth then
                        lowestHealth = player.Character.Humanoid.Health
                        closestPlayer = player
                    elseif not prioritizeLowHealth then
                        if fovEnabled then
                            local fovCenter = Vector2.new(mouseLocation.X, mouseLocation.Y)
                            local playerPos = Vector2.new(screenPoint.X, screenPoint.Y)
                            local fovDistance = (fovCenter - playerPos).Magnitude

                            if fovDistance <= fovRadius and distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        else
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function applyPrediction(position, amount, target)
    local predictedPos = position
    if velocityPrediction and target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local targetVelocity = target.Character.HumanoidRootPart.Velocity
        predictedPos = predictedPos + targetVelocity * amount
    end
    return predictedPos
end

local function aimAt(position)
    local mouseLocation = UserInputService:GetMouseLocation()
    local aimPos = Vector2.new(position.X, position.Y)
    local delta = aimPos - mouseLocation

    if math.abs(delta.X) > 0.1 or math.abs(delta.Y) > 0.1 then
        mousemoverel(delta.X / (aimSmoothness * aimSpeedX), delta.Y / (aimSmoothness * aimSpeedY))
    end
end

local function aim(target)
    if target and target.Character and getAimPart(target) then
        while (aimMode == "On-Hold" and UserInputService:IsKeyDown(aimKey)) or (aimMode == "On-Press" and aimbotEnabled) do
            if shouldHit() then  -- Check hit chance
                local aimPartPosition = getAimPart(target)
                local screenPoint = CurrentCamera:WorldToScreenPoint(aimPartPosition)
                local predictedPos = predictionEnabled and applyPrediction(aimPartPosition, predictionAmount, target) or aimPartPosition
                aimAt(Vector2.new(screenPoint.X, screenPoint.Y))
                
                if autoFire then  -- Auto fire feature
                    mouse1click()
                end
            end
            
            if switchTarget and fovEnabled then
                local newTarget = getClosestPlayer()
                if newTarget and newTarget ~= target then
                    target = newTarget
                end
            end

            if smartSwitch then  -- Smart switch feature
                local isObstructed = CurrentCamera:ScreenPointToRay(screenPoint.X, screenPoint.Y).Direction:Dot((aimPartPosition - CurrentCamera.CFrame.Position).unit) < 0.5
                if isObstructed or not target.Character:FindFirstChild("HumanoidRootPart").Visible then
                    target = getClosestPlayer()
                end
            end

            RunService.RenderStepped:Wait()

            if aimMode == "On-Press" then
                break
            end
        end
    end
end

-- Connect aim function to the key press event
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == aimKey and aimbotEnabled then
        local target = getClosestPlayer()
        if target then
            local distanceToTarget = (LocalPlayer.Character.HumanoidRootPart.Position - target.Character.HumanoidRootPart.Position).Magnitude
            if autoDisableAim and distanceToTarget > autoDisableDistance then
                aimbotEnabled = false
                wait(0.5)
                aimbotEnabled = true
            else
                aim(target)
            end
        end
    end
end)

-- Update FOV shape drawing each frame
RunService.RenderStepped:Connect(drawFOVShape)


-- Connect the FOV drawing to the render loop
RunService.RenderStepped:Connect(function()
    drawFOVShape()
end)

-- Configuration
local espEnabled = false
local espDistance = 489
local espTextSize = 18
local espLineThickness = 1
local espPadding = 10
local rainbowSpeed = 10
local espTextColor = Color3.new(1, 1, 1)

local showUsernameInESP = true
local showHealthInESP = true
local showDistanceInESP = true
local showStatusInESP = true
local rainbowESP = true

local espData = {}

-- Utility Functions
local function createDrawing(type, properties)
    local drawing = Drawing.new(type)
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    return drawing
end

local function getRainbowColor(t)
    local r = math.sin(t * rainbowSpeed * 2 * math.pi) * 0.5 + 0.5
    local g = math.sin(t * rainbowSpeed * 2 * math.pi + 2 * math.pi / 3) * 0.5 + 0.5
    local b = math.sin(t * rainbowSpeed * 2 * math.pi + 4 * math.pi / 3) * 0.5 + 0.5
    return Color3.new(r, g, b)
end

local function setupESP(player)
    espData[player] = {
        board = createDrawing("Square", {
            Filled = true,
            Thickness = espLineThickness,
            Color = espTextColor,
            Visible = false
        }),
        username = createDrawing("Text", {
            Size = espTextSize,
            Center = true,
            Outline = true,
            OutlineColor = Color3.new(0, 0, 0),
            Color = espTextColor,
            Visible = false
        }),
        health = createDrawing("Text", {
            Size = espTextSize,
            Center = true,
            Outline = true,
            OutlineColor = Color3.new(0, 0, 0),
            Color = espTextColor,
            Visible = false
        }),
        distance = createDrawing("Text", {
            Size = espTextSize,
            Center = true,
            Outline = true,
            OutlineColor = Color3.new(0, 0, 0),
            Color = espTextColor,
            Visible = false
        }),
        status = createDrawing("Text", {
            Size = espTextSize,
            Center = true,
            Outline = true,
            OutlineColor = Color3.new(0, 0, 0),
            Color = espTextColor,
            Visible = false
        }),
    }
end

local function updateESP(player, position, health, distance, status)
    local esp = espData[player]
    if not esp then return end

    local espColor = rainbowESP and getRainbowColor(tick() % 5 / 5) or espTextColor
    local offset = espPadding
    local maxWidth, totalHeight = 0, 0

    -- Update and position ESP elements
    if showUsernameInESP then
        esp.username.Text = "Player: " .. player.DisplayName
        esp.username.Position = Vector2.new(position.X, position.Y - offset)
        esp.username.Color = espColor
        esp.username.Size = espTextSize
        esp.username.Visible = true
        maxWidth = math.max(maxWidth, esp.username.TextBounds.X)
        totalHeight = totalHeight + esp.username.TextBounds.Y
        offset = offset + esp.username.TextBounds.Y + 5
    else
        esp.username.Visible = false
    end

    if showHealthInESP then
        esp.health.Text = "Health: " .. math.floor(health)
        esp.health.Position = Vector2.new(position.X, position.Y - offset)
        esp.health.Color = espColor
        esp.health.Size = espTextSize
        esp.health.Visible = true
        maxWidth = math.max(maxWidth, esp.health.TextBounds.X)
        totalHeight = totalHeight + esp.health.TextBounds.Y
        offset = offset + esp.health.TextBounds.Y + 5
    else
        esp.health.Visible = false
    end

    if showDistanceInESP then
        esp.distance.Text = "Distance: " .. math.floor(distance)
        esp.distance.Position = Vector2.new(position.X, position.Y - offset)
        esp.distance.Color = espColor
        esp.distance.Size = espTextSize
        esp.distance.Visible = true
        maxWidth = math.max(maxWidth, esp.distance.TextBounds.X)
        totalHeight = totalHeight + esp.distance.TextBounds.Y
        offset = offset + esp.distance.TextBounds.Y + 5
    else
        esp.distance.Visible = false
    end

    if showStatusInESP then
        esp.status.Text = "Status: " .. status
        esp.status.Position = Vector2.new(position.X, position.Y - offset)
        esp.status.Color = espColor
        esp.status.Size = espTextSize
        esp.status.Visible = true
        maxWidth = math.max(maxWidth, esp.status.TextBounds.X)
        totalHeight = totalHeight + esp.status.TextBounds.Y
        offset = offset + esp.status.TextBounds.Y + 5
    else
        esp.status.Visible = false
    end

    -- Update board size and position
    if espPadding > 0 then
        local padding = espLineThickness
        esp.board.Size = Vector2.new(maxWidth + padding * 2, totalHeight + padding)
        esp.board.Position = Vector2.new(position.X - esp.board.Size.X / 2, position.Y - esp.board.Size.Y)
        esp.board.Visible = true
        esp.board.Color = espColor
    else
        esp.board.Visible = false
    end
end

local function hideESP(player)
    if espData[player] then
        for _, drawing in pairs(espData[player]) do
            drawing.Visible = false
        end
    end
end

local function removeESP(player)
    if espData[player] then
        for _, drawing in pairs(espData[player]) do
            drawing:Remove()
        end
        espData[player] = nil
    end
end

local function applySettingsToAllESP()
    for _, esp in pairs(espData) do
        esp.username.Size = espTextSize
        esp.username.Color = espTextColor
        esp.health.Size = espTextSize
        esp.health.Color = espTextColor
        esp.distance.Size = espTextSize
        esp.distance.Color = espTextColor
        esp.status.Size = espTextSize
        esp.status.Color = espTextColor
        esp.board.Thickness = espLineThickness
    end
end

-- Main update loop with milliseconds response
RunService.RenderStepped:Connect(function()
    applySettingsToAllESP()
    if espEnabled then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if not espData[player] then
                    setupESP(player)
                end

                local rootPart = player.Character.HumanoidRootPart
                local health = player.Character.Humanoid.Health
                local distance = (rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                local pos, onScreen = CurrentCamera:WorldToScreenPoint(rootPart.Position)

                if onScreen and distance <= espDistance then
                    local status = health > 0 and "Alive" or "Dead"
                    updateESP(player, pos, health, distance, status)
                else
                    hideESP(player)
                end
            else
                removeESP(player)
            end
        end
    else
        for _, player in ipairs(Players:GetPlayers()) do
            removeESP(player)
        end
    end
end)

-- Clean up when players leave
Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)


Combat:AddToggle({
	Name = "Aimlock (Mouse Movement)",
	Default = false,
	Callback = function(Value)
		aimbotEnabled = Value
	end    
})

Combat:AddToggle({
	Name = "Aimlock for FOV",
	Default = false,
	Callback = function(Value)
		fovEnabled = Value
        fovVisible = Value
	end    
})

Combat:AddToggle({
	Name = "Predictions",
	Default = false,
	Callback = function(Value)
		predictionEnabled = Value
	end    
})

Combat:AddToggle({
	Name = "Rainbow FOV",
	Default = false,
	Callback = function(Value)
		rainbowFov = Value
	end    
})

Combat:AddToggle({
	Name = "Switch Target",
	Default = false,
	Callback = function(Value)
		switchTarget = Value
	end    
})

Combat:AddToggle({
	Name = "Dynamic FOV",
	Default = false,
	Callback = function(Value)
		dynamicFOV = Value
	end    
})

Combat:AddToggle({
	Name = "Team Check",
	Default = false,
	Callback = function(Value)
		filterByTeam = Value
	end    
})

Combat:AddToggle({
	Name = "Filter By Health",
	Default = false,
	Callback = function(Value)
		filterByHealth = Value
	end    
})

Combat:AddToggle({
	Name = "Randomize Hit Chance",
	Default = false,
	Callback = function(Value)
		randomizeHitChance = Value
	end    
})

Combat:AddToggle({
	Name = "Prioritize Low-Health",
	Default = false,
	Callback = function(Value)
		prioritizeLowHealth = Value
	end    
})

Combat:AddToggle({
	Name = "Auto Disable Distance",
	Default = false,
	Callback = function(Value)
		autoDisableAim = Value
	end    
})

Combat:AddToggle({
	Name = "Auto Fire",
	Default = false,
	Callback = function(Value)
		autoFire = Value
	end    
})

Combat:AddToggle({
	Name = "Velocity Predictions",
	Default = false,
	Callback = function(Value)
		velocityPrediction = Value
	end    
})


Combat:AddToggle({
	Name = "Smart Switch",
	Default = false,
	Callback = function(Value)
		smartSwitch = Value
	end    
})

-- Aimlock sliders here

Combat:AddSlider({
	Name = "FOV Size",
	Min = 50,
	Max = 500,
	Default = 50,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		fovRadius = Value
	end    
})

Combat:AddSlider({
	Name = "Smoothness",
	Min = 1,
	Max = 10,
	Default = 4.9,
	Color = Color3.fromRGB(255, 255, 255),
	Increment = 0.1,
	ValueName = "%",
	Callback = function(Value)
		aimSmoothness = math.floor(Value * 10) / 10
	end    
})


Combat:AddSlider({
	Name = "Distance",
	Min = 100,
	Max = 950,
	Default = 489,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		aimlockDistance = Value
        autoDisableDistance = Value
	end    
})


Combat:AddSlider({
	Name = "Predictions",
	Min = 1,
	Max = 10,
	Default = 489,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.1,
	ValueName = "%",
	Callback = function(Value)
		predictionAmount = Value
	end    
})


Combat:AddSlider({
	Name = "Hit Chance",
	Min = 1,
	Max = 100,
	Default = 75,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		hitChance = Value
	end    
})


Combat:AddSlider({
	Name = "Aim Speed",
	Min = 1,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		aimSpeed = math.floor(Value * 10) / 10
	end    
})

Combat:AddSlider({
	Name = "X Offset",
	Min = 0,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.1,
	ValueName = "%",
	Callback = function(Value)
		x = math.floor(Value * 10) / 10
	end    
})

Combat:AddSlider({
	Name = "Y Offset",
	Min = 0,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.1,
	ValueName = "%",
	Callback = function(Value)
		y = math.floor(Value * 10) / 10
	end    
})

Combat:AddSlider({
	Name = "Z Offset",
	Min = 0,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 0.1,
	ValueName = "%",
	Callback = function(Value)
		z = math.floor(Value * 10) / 10
	end    
})


Combat:AddSlider({
	Name = "Aim Speed Offset X",
	Min = 1,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		aimSpeedX = math.floor(Value * 10) / 10
	end    
})

Combat:AddSlider({
	Name = "Aim Speed Offset Y",
	Min = 1,
	Max = 10,
	Default = 0.1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		aimSpeedY = math.floor(Value * 10) / 10
	end    
})

-- sliders ends here

Combat:AddDropdown({
	Name = "Aim Part",
	Default = "UpperTorso",
	Options = {"Head", "UpperTorso", "HumanoidRootPart"},
	Callback = function(Value)
		aimPart = Value
	end    
})

Combat:AddDropdown({
	Name = "Aim Mode",
	Default = "On-Hold",
	Options = {"On-Hold", "On-Press"},
	Callback = function(Value)
		aimMode = Value
	end    
})

Combat:AddDropdown({
	Name = "Fov Shape",
	Default = "Circle",
	Options = {"Circle", "Square"},
	Callback = function(Value)
		fovShape = Value
	end    
})

--- The Esp Sections starts here

Esp:AddToggle({
	Name = "Esp (F1 toggle)",
	Default = false,
	Callback = function(Value)
		espEnabled = Value
	end    
})


Esp:AddToggle({
	Name = "Show User",
	Default = false,
	Callback = function(Value)
		showUsernameInESP = Value
	end    
})


Esp:AddToggle({
	Name = "Show Health",
	Default = false,
	Callback = function(Value)
		showHealthInESP = Value
	end    
})

Esp:AddToggle({
	Name = "Show Distance",
	Default = false,
	Callback = function(Value)
		showDistanceInESP = Value
	end    
})

Esp:AddToggle({
	Name = "Show Status",
	Default = false,
	Callback = function(Value)
		showStatusInESP = Value
	end    
})

Esp:AddToggle({
	Name = "Show Box",
	Default = false,
	Callback = function(Value)
		showBoxInESP = Value
	end    
})

Esp:AddToggle({
	Name = "Show Tracer",
	Default = false,
	Callback = function(Value)
		showTracerInESP = Value
	end    
})


Esp:AddToggle({
	Name = "Show Skeleton",
	Default = false,
	Callback = function(Value)
		showSkeletonInESP = Value
	end    
})

Esp:AddToggle({
	Name = "Show Esp Out FOV ",
	Default = false,
	Callback = function(Value)
		showOutOfFOV = Value
	end    
})

Esp:AddToggle({
	Name = "Rainbow Esp",
	Default = false,
	Callback = function(Value)
		rainbowESP = Value
	end    
})

-- Esp sliders here

Esp:AddSlider({
	Name = "Distance",
	Min = 100,
	Max = 950,
	Default = 489,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		espDistance = Value
	end    
})

Esp:AddSlider({
	Name = "Esp Text Size",
	Min = 1,
	Max = 250,
	Default = 18,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%%%",
	Callback = function(Value)
		espTextSize = Value
	end    
})

Esp:AddSlider({
	Name = "Rainbow Speed",
	Min = 1,
	Max = 8,
	Default = 1,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "%",
	Callback = function(Value)
		rainbowSpeed = Value
	end    
})


Esp:AddSlider({
	Name = "Esp Thickness",
	Min = 0,
	Max = 100,
	Default = 0,
	Color = Color3.fromRGB(255,255,255),
	Increment = 10,
	ValueName = "%",
	Callback = function(Value)
		espPadding = Value
	end    
})

Esp:AddColorpicker({
	Name = "Esp Color Picker",
	Default = Color3.fromRGB(255, 0, 0),
	Callback = function(Value)
		espTextColor = Value
	end	  
})


OrionLib:Init()
